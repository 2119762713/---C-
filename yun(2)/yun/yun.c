#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h> //标准输出输入库文件

#include <string.h>//printf("%d\n",strlen(arr1))---------strlen:计算长度 //strcmp() //strcmp是判断TRIO 里面的数据是不是我是猪 ，如果等于就返回一个0,如果第一个大于第二个就返回一个大于0的数，如果第一个小于第二个就返回一个小于0的数//getchar()    putchar()
//strcpy(arr2, arr1);//strcpy就是拷贝的意思，把arr1拷贝到赋值arr2里面去。arr2就变成了 bit

#include <limits.h>//引入这个头文件就可以看类型最大能存储的值了 //INT_MAX

#include <stdlib.h>//ststem() //system()--C语言专门用来执行系统命令的函数//system("cls");//执行系统命令的一个函数.//cls---是Windows清空屏幕的意思//RAND_MAX;//0x7fff十六进制===十进制32767
//int ret = rand();//rand（）专门用来生成随机数的函数---c语言自带的srand(1);//使用rand（）随机函数前需要调用（不调用就会有bug）srand()函数来生成生成器，srand(1)中的1就是从1开始随机生成

#include <windows.h>//Sleep(10);--延迟执行，也可以是多少秒执行

#include <math.h>//sqrt -开平方的数学库函数

#include <time.h>






//========================================================================
//========================================================================
//========================================================================
//========================================================================
//========================================================================
//========================================================================
//========================================================================
//========================================================================
//========================================================================
//========================================================================
//========================================================================
//========================================================================
//========================================================================
//算术转换
//1.如果某个操作符的各个操作数属于不同的类型, 那么除非其中一个操作数的转换为另一个操作数的类
//型, 否则操作就无法进行。下面的层次体系称为寻常算术转换。
//========================================================================
////1.隐式类型转换
////C的整型算术运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度, 表达式中的字符和短整型操作数在使用之前被转换为普通整型, 
////这种转换称为整型提升.
////表达式中各种长度可能小于int长度的整型值都会隐式类型转换
////举例1
////如何进行整体提升呢 ?
////整形提升是按照变量的数据类型的符号位来提升的
//void main()
//{
//    char a = 3;
//    //3的二进制位：00000000000000000000000000000011  //为什么是二进制位，因为存储到内存里面是以二进制形式存储的，所以需要转换
//    //但是char类型只有1字节空间也就是8bit为 二进制：0000 0011  //他会把多余的位数截断不要，从最小最低为开始数到第8位就截断掉，前面的就不要了
//    //char类型 变量名a 里面存放的就是：0000 0011
//    char  b = 127;
//    //127进制位：000000000000000000000000‭01111111‬  //为什么是二进制位，因为存储到内存里面是以二进制形式存储的，所以需要转换
//    //但是char类型只有1字节空间也就是8bit为 二进制：‭0111 1111‬  //他会把多余的位数截断不要，从最小最低为开始数到第8位就截断掉，前面的就不要了
//    //char类型 变量名a 里面存放的就是：‭0111 1111‬
//    char c = a + b;
//    //a+b 就是：00000000 00000000 00000000 00000011 + 00000000 00000000 00000000 01111111 
//    //00000000 00000000 00000000 00000011//为什么又是32位bit位呢，因为隐式类型转换他会算术运算不是普通整形的转换成普通整形也就是int型 int4字节也就是 32位bit位
//    //00000000 00000000 00000000 01111111
//    //00000000 00000000 00000000 10000010 //然后又放到c里面去，c是char类型 1字节 又要截断也就是1000 0010 
//    //但是我们要打印整形我们就需要隐式类型转换成普通整形：11111111 11111111 11111111 10000010 //为什么是补1 因为每转化前符号位是1，所以是按符号位是几就补几
//    //转换成反码：11111111 11111111 11111111 10000001
//    //转换成原码打印就是：10000000 00000000 00000000 01111110 ==-126
//    printf("%d\n",c);//注意为什么每次都要转换，因为打印的都是二进制位的原码不是补码，而存储内存中的二进制是补码
//}
//========================================================================
////结构体---体现或者描述一个对象
//struct xiux//这是创建一个结构体类型 类型名叫xiux
//{
//    //成员变量
//    char name[20];
//    int age;
//    char id[20];
//};
//
//void main()
//{
//    //使用struct xiux这个结构体类型创建了一个学生对象duxain,并且初始化
//    struct xiux duixain={"张三",20,"200102028"};
//    struct xiux* p = &duixain;//取duixain对象的地址存放到struct xiux 结构体指针变量里面
//
//    //1.通过对象duixain找到成员属性并且打印实现出来
//    printf("%s\n", duixain.name);
//    printf("%d\n", duixain.age);
//    printf("%s\n", duixain.id);
//
//    //2.通过指针地址找到成员属性并且实现打印出来,但是这样有点啰嗦麻烦
//    printf("%s\n", (*p).name);
//    printf("%d\n", (*p).age);
//    printf("%s\n", (*p).id);
//
//    //3.通过指针地址， 并且使用 -> 找到成员属性并且实现打印出来，这个和上面的使用地址指针实现打印的方法是一样的
//    printf("%s\n", p->name);//->的意思就是p指针地址（p） 指向的(->) 那个对象的内容(name)
//    //结构体指针 - > 成员名
//    printf("%d\n", p->age);
//    printf("%s\n", p->id);
//}
//========================================================================
////逗号表达式
////就是用逗号隔开的多个表达式。逗号表达式, 从左向右依次执行。整个表达式的结果是最后一个表达式的结果。
//void main()
//{
//    int a = 1;
//    int b = 2;
//    int c = (a>b,a=b+10,a,b=a+1);//逗号表达式
//    printf("%d\n",c);//结果13
//}
//========================================================================
////条件表达式
//void main()
//{
//    int b = 3;
//    int c = 5;
//    int a = (b>c?3:-3);//这个括号里面的意思就是：b大于c为真就执行3，如果b大于c为假就执行-3，b大于c为假，所以执行-3
//    printf("%d\n",a);//结果为负-3
//}
//========================================================================
////逻辑操作符
//void main()
//{
//    //&&逻辑操作符--就是两边是对才是对的否则就是错的
//    //两边为真就才为真，否则为假
//    //假是0，真是非0的数，一般打印出来的真都是用1代替
//    int a = 3;
//    int b = 5;
//    int c = a && b;
//    printf("%d\n",c);
//
//    //||逻辑操作符--就是一边为真就为真，同时两边为真也为真，只有两边为假才为假.
//    int a1 = 0;
//    int b1 = 5;
//    int d = a1 || b1;
//    printf("%d\n",d);
//}
//========================================================================
//void test1(int arr[])
//{
//    printf("%zd\n", sizeof(arr));//8
//}
////为什么是大小8呢，因为传参传过来的是数组首元素地址，地址是指针类型，所以接收到的是地址，地址是根据你是32还是64位平台来判断空间大小的
////32位是4字节，64位是8字节，因为我是64位平台所以是打印大小8
//void test2(char ch[])
//{
//    printf("%zd\n", sizeof(ch));//8
//}
//
//void main()
//{
//    int arr[10] = {0};
//    char ch[10] = {0};
//    printf("%zd\n", sizeof(arr));//40
//    printf("%zd\n", sizeof(ch));//10
//    test1(arr);
//    test2(ch);
//}
//========================================================================
////单目操作符：只有一个操作数通俗一点就是只有一边有数值a-- s++ 这些就是单目操作符
//void main()
//{
//    int a = 10;
//    printf("%d\n",!a);//！就是把真变假，把假变真，0为假，真为非0的数,只要不是0就是真
//
//    a = -6;//负号
//
//    int* b = 0;
//    b= &a; //&取地址操作符
//    *b=6;//*解引用操作符//意思就是通过b里面的地址找到存储的对象，=6就是把6赋值到这个变量b存储的地址里面的数值或者说的对象
//    printf("%p\n",b);
//    
//    int c=sizeof(a=a+2);//sizeof里面的表达式是不做运算的//就是用来计算变量，数值，指针，类型这些所占的的空间大小 大小的单位是4字节
//    printf("%d\n", c);
//
//    //~按(2进制)位取反
//    //2的二进制位：0000000000000000000000000000000010
//    //2的二进制位：1111111111111111111111111111111101 //这是负数的补码还要转换成原码
//    //反码       ：1111111111111111111111111111111100
//    //最后的原码 ：1000000000000000000000000000000011 == -3
//    printf("%d\n",~2);//结果等于负三-3
//
//    int a3 = 10;
//    printf("%d\n",++a3);//结果11//前置++，先++，后使用
//    int a4 = 10;
//    printf("%d\n",a4++);//结果10//后置++，先使用，再++
//
//    //（类型）括号里面加类型就是强制转换的意思
//    int a5 = (int)3.14;//这样就会警告，我们就可以转换类型,(类型)括号里面类型就是把3.14浮点数转换成int型，但是数值可能会被丢失
//    printf("%d\n",a5);
//}
//========================================================================
////复合操作符
//void main()
//{
//    int a = 10;
//    a = a + 2;
//    a += 2;//和上面的效果一样
//
//    a=a >> 1;
//    a >>= 1;//和上面效果一样
//
//    a = a & 1;
//    a &= 1;//和上面效果一样
//
//    //下面什么-= *= /= %= 都是一样的
//}
//========================================================================
////编写代码实现:求一个整数存储在内存中的二进制中1的个数
////为什么可以这么算呢，因为二进制从左边第一位到右边但是左边的2倍，所以除以2，而余1的是因为那个数余1就绝对二进制位是有个1
//void main()
//{
//  
//    int num = 0;
//    int count = 0;//计数器
//    int b=scanf("%d",&num);
//    //统计num的补码中有几个1
//     //只能用于正数
//    //假如num是3 第一次循环3%2==1成功 执行count++ 3除以2==1赋值给num 第二次循环1%2==1成功 count++; 1除以2==0 为假不循环了，输出结果为2
//    //while (num)
//    //{
//    //    if (num%2==1)
//    //        count++;
//    //    num = num / 2;//这里就相当于拆分3 除以2 == 1 3和1二进制位是011 01 这样就统计了二进制位上有几个一了
//    //}
//    //正数和负数都可以
//    int i = 0;
//    for (i=0;i<32;i++)
//        //为什么是32位呢因为数值转换成二进制就是32位，所以是32
//    {
//        if (1==((num>>i)&1))//这里的算法就是
//            //1111111111111111111111111111111111  //这是一的补码异或后
//            //num左位移i就是每次判断那个位置是不是余1，只要是不是0肯定都余1,
//            //0111111111111111111111111111111111  //这样一直循环到值为32时就结束也就是00000000000000000000000000000000
//        {
//            count++;
//        }
//    }
//    printf("%d\n",count);
//}
//========================================================================
////实现两个变量交换，不用第三个变量
//void main()
//{
//    //1.使用了第三个变量交换
//    int a = 3;
//    int b = 5;
//    int mtp = 0;
//    printf("交换前 a=%d b=%d",a ,b);
//    mtp = a;
//    a = b;
//    b = mtp;
//    printf("交换后 a=%d b=%d", a, b);
//    //这样就实现了两个变量交换，但是用了第三变量
//
//    //2.方法加减
//    //这种方法有缺陷---就是a+b如果大于了4字节的容量就溢出了，溢出了后面结果也就不对了
//    int a = 3;
//    int b = 5;
//    printf("加减前 a=%d b=%d", a, b);
//    a = a + b;//3+5=8
//    b = a - b;//8-5=3
//    a = a - b;//8-3=5
//    printf("加减后 a=%d b=%d", a, b);
//
//    //3.方法异或
//   //这种方法就没有上面的缺陷，但是也有缺陷---就是运行效率可能没有上面的两个高,可读性比较差，第一个方法最运行最快可读性高，一般使用第一种
//    int a = 3;
//    int b = 5;
//    printf("加减前 a=%d b=%d", a, b);
//    a = a ^ b;//a==6
//    //3二进制位是：011
//    //5二进制位是：101
//    //异或结果是 ：110==6
//    b = a ^ b;//b==3
//    //a==6二进制位是：110
//    //b==5二进制位是：101
//    //异或结果是 ：011==3
//    a = a ^ b;//a==5
//    //a==6二进制位是：110
//    //b==3二进制位是：011
//    //异或结果是 ：101==5
//    printf("加减后 a=%d b=%d", a, b);
//    //简单分析就是：a^b得到一个新的数值   新的数值^a就得到b 新的数值^b就得到a  这个结果是必然的
//}
//========================================================================
////操作符的深度认识2
//void main()
//{
//    ////&-按二进制位与
//    //int a = 3;
//    //int b = 5;
//    //int c = 3 & 5;
//    ////3的二进制位：00000000000000000000000000000011
//    ////5的二进制位：00000000000000000000000000000101
//    ////与的结果：   00000000000000000000000000000001  //算法就是3和5二进制位对比：两边为1才为1，否则都为0(两边为真才为真，否则为假)
//    //printf("%d\n",c);//结果是1.
//
//    ////|-按二进制位或
//    //int a = 3;
//    //int b = 5;
//    //int c = 3 | 5;
//    ////3的二进制位：00000000000000000000000000000011
//    ////5的二进制位：00000000000000000000000000000101
//    ////或的结果是 ：00000000000000000000000000000111 //算法就是3和5二进制位对比：一边为1就为1，两边为1也为1，否则为0(一边为真就为真，两边为真也为真，否则为假)
//    //printf("%d\n", c);//结果是7.
//
//    //^-按二进制位异或
//    //相同为0，相异为1
//    int a = 3;
//    int b = 5;
//    int c = 3 ^ 5;
//    //3的二进制位：00000000000000000000000000000011
//    //5的二进制位：00000000000000000000000000000101
//    //异或的结果是 ：00000000000000000000000000000111 //算法就是3和5二进制位对比：两边一样就为0，两边不同就为1
//    printf("%d\n", c);//结果是6.
//
//    //注意以上的操作必须是int整形.
//}
//========================================================================
////操作符的深度认识1
//void main()
//{
//    ////int a = 5 / 2;//这是5除以2得到商2余1
//    //double a = 5.0 / 2;//这是5除以2得到商2余1
//    ////还有就是5除以2表示得到2.5吗，如果你要得到这种结果，两个数其中必须有一个数是小数也就是浮点型
//    ////printf("%d\n",a);//这是打印5除以2得到的商
//    //printf("%lf\n",a);//这是打印5除以2得到的商
//    //double b = 5 % 2;//注意：取模两边的数必须是整数，但是把接受的类型改成浮点数得到的结果接受浮点数//这是5取模2得到的余数1
//    //printf("%lf\n", b);//这是打印5取模2得到的余
//    int a = 1;
//    //二进制位是： 0000 0001
//    //位移之后是： 0000 0000
//    int b =a >> 1;//这是算术右移//右移操作符：移动的是你要移动数的二进制位
//    //0001 0000 >>右移动一位 结果是0 00 1000(不足之前的位数自动补零) 转换成十进制是==8
//    printf("%d\n",b);
//    //算术右移操作符：右边丢弃,左边补原符号位
//    //逻辑右移：右边丢弃，左边补0
//    int a1 = -1;//调试里面内存监控窗口得到的结果是：ff ff ff ff
//    //1个f是一个字节转换成比特位就是4个bit位，总共是32个bit位//一个f就是十六进制的也是十进制的15 转换成二进制就是 1111
//    //整数的二进制表示有：原码 反码 补码 //而存储到内存的补码//注意：正数的原码 补码 反码 是一样的,而负数原码 反码 补码 都不一样
//    //-1的原码：10000000000000000000000000000001(32位bit位)//注意：不管是负数还是正数他们的第一位数都是符号位(0代表：正数，1代表：负数)
//    //-1的反码：11111111111111111111111111111110
//    //-1的补码：11111111111111111111111111111111 
//    //右移动一位就是: 11111111111111111111111111111111  为什么没有变化，因为你向右移动一位消除后，前面又补了1
//    int b1 = a >> 1;//-1结果还是-1
//
//    int a2 = 5;
//    // 二进制位是：0000 0101 
//    //左移一位是： 0000 1010  //记住多的位数就会删减掉不要，后面补0
//    int b2 = a2 << 1;
//    printf("%d\n",b2);//结果是
//    
//}
//========================================================================
//void main()
//{
//    int arr[10] = {1,2,3,4,5};
//    printf("%p\n",arr);//这样和下面的取地址还是一样的效果都是打印的地址//数组名是数组首元素的地址，
//    int sz = sizeof(arr) / sizeof(arr[0]);
//    //1. sizeof (数组名)---数组名表示整个数组，sizeof (数组名)计算的是整个数组的大小，单位是字节,这里的数组名是整个数组而不是数组的首元素
//    printf("%p\n",&arr);//你看到打印结果是不是以为也是取的首元素地址，错，因为他是数组的地址，而不是首元素的地址，你只要加1他和其他打印的首元素加1地址是不一样的，因为他+1打印的是首元素到最后一个元素，这就是区别
//    //2. &数组名,数组名代表整个数组，数组名,取出的是整个数组的地址，而不是首元素地址
//    printf("%p\n",&arr[0]);//这样和上面的取地址还是一样的效果都是打印的地址
//    printf("%d\n",*arr);//这样打印的结果就可以说明test函数传参，传的是首元素的地址//1
//}
//========================================================================
////数组作为函数参数
////数组冒泡排序
//void test(int arr[],int sz)//这里int arr[]实际上是一个指针，这也就是为什么函数里面的sizeof获取不到数组的长度或者说是因为数组只传了一个首元素。
//{
//    //确定冒泡排序的趟数
//    int i = 0;
//    for (i = 0; i < sz-1; i++)//这里是循环数组的次数
//    {
//        //每一趟冒泡排序
//        int fo = 1;//优化1
//        int j = 0;
//        for (j = 0; j <sz- 1-i; j++)//这里是循环两个数交换的次数//sz-i-1==10-0-1==9
//            //下次循环8次依次类推，因为最大的数已经排到了最后后面了，也就没必要去再多一次循环
//        {
//            if (arr[j]>arr[j+1])
//            {
//                int b = arr[j];//这里是备份每次第一个元素的数值
//                arr[j] = arr[j + 1];//这里就是如果第一个元素大于第二个元素就交换，注意：这里是把main函数里面的数组地址的值互换，不会存在问题
//                arr[j+1] = b;//这里就是和上面的互换
//                fo = 0;//优化1//如判断成功就赋值0
//            }
//        }
//        if (fo==1)//优化1//这就是判断j循环如果没有大于的情况下就直接跳出//这个针对数组是 9 1 2 3 4 5 6 7 8的情况，这样就可以节省多余循环判断代码量，就没必要后面还去判断1 2 3....8大不大于
//        //不用担心循环判断会不会出问题，因为j循环里面会判断的，他会判断一个数是不是小于全部的数，如果是就可以跳出了，如果不是他会循环sz-1-i
//        {
//            break;//优化1跳出
//        }
//    }
//}
//void main()
//{
//    int arr1[] = {9,8,7,6,5,4,3,2,1};
//    int i = 0;
//    int sz = sizeof(arr1) / sizeof(arr1[0]);
//    //对arr进行排序, 排成升序
//    //arr是数组，我们对数组arr进行传参,传参传递的是数组的第一个元素地址
//    test(arr1,sz);//冒泡排序函数
//    for (i = 0; i < sz; i++)
//    {
//        printf("%d ",arr1[i]);//循环打印出来
//    }
//    //冒泡排序10,9,8,7,6,5,4,3,2,1
//    //10,9,8,7,6,5,4,3,2,1
//    //9,10,8,7,6,5,4,3,2,1
//    //9,8,10,7,6,5,4,3,2,1
//    //9,8,7,10,6,5,4,3,2,1
//    //最后
//    //9,8,7,6,5,4,3,2,1,10//这是一趟冒泡排序直到变成1 2 3 4 5 6 7 8 9 10
//
//}
//========================================================================
////二维数组的创建和初始化并且使用
//void main()
//{
//    //int arr[3][4] = {1,2,3,4,5};//这样赋值不会溢出吗，不会，因为第一行装不下了就可以放到第第二行去了（注意就是4列也是说明每行可以放四个元素）//[3][4]就是3行4列
//    //怎么样把1 2放到第一行，再把3 4 5放到第二行呢，我们可以这样
//    //int arr[3][4] = {{1,2,3},{4,5}};//这样就是可以了，同时没有赋值的元素默认是0//这也是二维数组的默认初始化
//    //char ch[4][5];//[4][5]就是4行5列
//    //int arr1[][4] = { {1,2,3,4},{5,6,7,8}};//注意列是不可以省略的，行可以
//    int arr2[3][4] = { {1,2,3,4},{5,6,7,8} };
//    int i = 0;
//    for (i = 0; i < 3; i++)
//    {
//        int j = 0;
//        for (j = 0;j < 4; j++)
//        {
//            printf("arr[%d][%d]=%d ",i+1,j+1,arr2[i][j]);//不+1那就是下标不是行和列了//这样就能打印二维数组的元素了
//            //同样的二维数组的地址排序还是有序并且连续的，间隔还是4，并不会因为几行几列地址就变了
//        }
//        printf("\n");
//    }
//    // 0 行  0 1 2 3 
//    // 1 行  0 1 2 3 
//    // 3 行  0 1 2 3 
//    //上面就是3行4列的下标，行和列也=都是从0开始的，行和列的下标都是==行和列的长度-1
//}
//========================================================================
////一维数组在内存中的存储
//void main()
//{
//    int arr[] = {1,2,3,4,5,6,7,8,9,10};
//    int sz = sizeof(arr) / sizeof(arr[0]);
//        for (int i = 0; i < sz; i++)
//        {
//           printf("%d=%p\n",i,&arr[i]);//这样打印出来的地址是有序并且连续的，因为地址是按十六进制打印的每个地址就间隔4，4又刚好是他们的内存大小
//        }
//}
//========================================================================
////一维数组的使用--[]访问数组的下标引用操作符
//void main()
//{
//    char arr[] = "abcdef";
//    printf("%c\n",arr[3]);//只有我们就能访问输出d了，为什么要arr[3]呢，因为d的下标是3，而[]是访问元素的下标引用操作符，注意：下标=你要取的字符长度-1
//    for (int i=0;i<strlen(arr);i++)//这样就能打印数组的全部元素//strlen(arr)就是求得数组长度，注意：下标是从0开始的 下标永远小于 数组长度-1，所以必须是<
//    {
//        printf("%c\n", arr[i]);//为什么是arr呢，因为i会一次一次递增，直到循环结束为止，而且数组的下标结束0-5，所以循环5次刚刚好全部打印出来
//    }
//}
//========================================================================
//void main()
//{
//    char arr[] = "abc";
//    char arr1[] = {'a','b','c'};
//    printf("%zd\n", sizeof(arr));//这里把\0也算做内容和空间没所以是4
//    printf("%zd\n", sizeof(arr1));//这里是没有\0所以空间里面只有a b c也就是空间大小3，也就输出3
//    printf("%zd\n", strlen(arr));//字符串默认最后一个元素为\0，所以他不会输出随机数
//    printf("%zd\n", strlen(arr1));//这里是随机数，因为strlen是计算长度的。但是因为arr1没有给固定元素也没有给结束标志\0，所以会一直查找下去直到随机查找到\0
//}
//========================================================================
////数组--数组的创建
////数组的初始化
////数组的初始化是指, 在创建数组的同时给数组的内容一些合理初始值(初始化)。
//void main()
//{
//    //创建一个数组
//    int arr[10] = {1,2,4};//这种方法叫不完整初始化，剩下的的元素默认初始化为0//int 是数组类型，arr是数组名，10是元素个数也就是存放10个int型数值
//    char arr1[5] = {'b','a',98};//为什么98输出的还是 b 呢，因为98是b的ASCII码值，所以输出b //字符型数组//这里的0是默认0
//    char arr2[5] = "ab";//字符型数组//字符串后面的元素的0是\0也是我放进去的，不是默认初始化0
//    char arr3[] = "abcdef";//这里元素还是6个，虽然我没有给元素个数，但是数组会根据你存储的值有几个来判断几个元素
//    printf("%zd\n",sizeof(arr3));//这里为什么是7个呢，因为sizeof把结束标志\0也算上长度了
//    //sizeof是专门用来计算空间大小的---计算变量，数组，类型的大小，单位是字节-----这就是操作符
//    printf("%zd\n",strlen(arr3));//这里是6是因为strlen没有把结束标志\0算作长度----这是库函数---使用得引入头文件
//    //strlen是专门计算字符串长度的--他只能求字符串的长度
//    //int n = 10;
//    //int arr3[n];//这样会报错因为[]里面只能是常量。
//}
//========================================================================
////函数和迭代
//////求n个斐波那契数列是什么//递归方法效率太低了
//////1 1 2 3 5 8 13 21 34 55---规律就是第一个数+第二个数=第三个数然后第二个数+第三个数=第四个数依次类推
//
////迭代的方法解决
//int test(int y)
//{
//    int a = 1;//这里的a是最开始的第一个斐波那契数
//    int b = 1;//这里的b是最开始的第一个斐波那契数
//    int c = 1;//这里的c是最开始的第一个斐波那契数//如果不是1的话，别人要第二个斐波那契数，2<=2的是不会进入判断发，所以直接返回一个0吗，所以必须是1
//   while (y>2)//如果小于2或者等于2就不用判断了，直接返回1就行，大于2我们就需要去算了
//    {
//        c = a + b;//比如a和b是第一个斐波那契数和第二个斐波那契数，那他们+=c就是第三个斐波那契数依次类推
//        a = b;//这里把b第二个斐波那契数赋值给a
//        b = c;//这里把c第三个斐波那契数赋值给b，这样下次循环就可以得到第四个斐波那契数数，这样依次类推
//        y--;
//    }
//   return c;
//}
////int a = 0;
////int test(int y)
////{
////    if (y == 3)
////    {
////        a++;
////    }
////    if (y<=2)//为什么是<=2呢，因为第一个斐波那契数和第二个斐波那契数都是1，也就返回一个1
////    {
////        return 1;
////    }
////    else
////    {
////        return test(y - 1) + test(y - 2);//原理就是要找第5给斐波那契数，就需要找第三个和第四个，第二个和第一个和需要第三个和第二个，这样依次类推
////        //假设我需要查找3的斐波那契数
////        //1. 为什么是return test(y - 1) + test(y - 2);呢，首先调用test函数（3-1也就是2）+调用test函数（3-2也就是1）//分别求的是第二个和第一个
////        //2.1 第一个调用函数返回的是1，因为第一个斐波那契数和第二个斐波那契数都是1所以直接返回1就可以了，这样就是得到第二个的的斐波那契数，然后返回斐波那契数1，最后和另外一个函数调用的返回的第二个斐波那契数值相加就得到第三个的斐波那契数
////        //2.2 第二个调用函数返回的是1，因为第一个斐波那契数和第二个斐波那契数都是1所以直接返回1就可以了==1+1=2这样就是得到第一个的的斐波那契数，然后返回斐波那契数1，最后和另外一个函数调用的返回第一个斐波那契数相加就得到第三个的斐波那契数
////        //最后相加返回一个2给main函数，因为第一个斐波那契数+第二个斐波那契数=第三个斐波那契数 然后第二个斐波那契数+第三个斐波那契数=第四个斐波那契数依次类推
////    }
////}
//
//void main()
//{
//    int n = 0;
//    int b = scanf("%d",&n);
//    //TDD--测试驱动开发,意思就是:我先实现怎么用这个函数，我再看这个函数怎么实现，就是怎么测怎么用，再怎么去写怎么开发
//    int ret = test(n);
//    printf("ret=%d\n",ret);
//    //printf("第三个斐波那契数3被查找了=%d\n",a);//为什么会查找这么多次呢，因为求15 的就需要14 和13 ，14又需要13 12 12 11
//    //                    6
//    //             4              5
//    //         3       2      4       3
//    //这就是为什么3会被查找这么多次，因为分支的问题//这样用递归函数的方法效率就很低了。
//}
//========================================================================
//递归和迭代
//求n的阶乘
//int Fal(int b)//这是用循环解决n的阶乘
//{
//    int i = 0;
//    int bbt = 1;
//    for (i = 1; i <= b; i++)
//    {
//        bbt *= i;
//    }
//    return bbt;
//}
//
//int Fal2(int b)//这是用递归解决n的阶乘
//{
//    if (b<=1)
//    {
//        return 1;//因为1的阶乘就是1
//   }
//    else
//    {
//        return b*Fal2(b-1);
//        //1. 为什么要b*Fal函数（b-1）呢，首先假如b是5：5*Fal函数(5-1也就是4)，此时b就是4呢，这样依次递归下去直到b被减到1为止也就没必要递归了，就可以直接返回1
//        //2. 第一次：5*4，第二次：5*4*3，第三次5*4*3*2，第四次：5*4*3*2*1，因为已经减到1，就可以把数值返回去了（注意：5*4不是真的就5乘以4了，而是我简化为了看懂而已，真的执行是先调用函数Fal然后传参4过去，然后这样循环直到最后2*1的时候把值返回然后：2*1=3*2*1=4*3*2*1=5*4*3*2*1，最后得到5的阶乘并且返回给main函数）//注意最后的返回的1就是1的阶乘所以不会有bug，因为1的阶乘是1就没必要再算了可以直接返回了
//        //3. 2*1=3*2*1=4*3*2*1=5*4*3*2*1==就是函数调用第5次=函数调用第4次=函数调用第3次=函数调用第2次=函数调用第1次=2*1==2*2==4*3==12*4==48*5==150并且把5返回，150就是5的阶乘
//    }
//}
//
//void main()
//{
//    int n = 0;
//    int b=scanf("%d",&n);
//    //int ret=Fal(n);//用循环的方式解决
//    int ret = Fal2(n);//用递归的方式解决
//    printf("%d\n",ret);
//}
//========================================================================
////用函数求字符串长度，用了临时变量i
//int test(char* str)//为什么是char* 类型呢，而不是数组类型，因为数组传参，传过来的不是整个数组，而是第一个元素的地址，地址需要指针变量接收
//{//计算字符串的长度
//    int i = 0;
//    while(*str!='\0')//这里计算判断地址里面的值是不是结束标志\0，只要不是就进入代码块。如果是那字符串也就知道长度了
//    {
//        i++;//统计字符串长度
//        str++;//数组第一个元素地址自增，为什么地址可以自增呢，因为数组元素地址排序是有顺序是连续的，所以可以自增
//    }
//    return i;//返回统计的字符串长度
//}
//////用递归函数求字符串长度，不用临时变量i//算法优化，好于上一个
//int test(char* str)
//{
//    //test("bit' )://递归的大概情况
//    //1+test("it" ) ;1
//    //1+1+test("t") ;1+1
//    //1+1+1+test("")1+1+1 
//    // 1+1+1+0
//    //3
//    if (*str != '\0')//不等于字符串结束标志才开始递归，如果等于结束标志时长度也就是查找完了，可以不用查找了
//    {
//        return 1 + test(str + 1);
//        //1.判断地址里面的数值是不是结束标志'\0'，如果不是就开始执行判断里面的代码，首先进入判断里面执行1+test(str+1),调用test函数传一个地址变量+1，这个是arr数组的下一个元素，然后再次判断这个地址是不是'\0'，地址还不是'\0',我们就继续调用test函数传一个地址变量+1，这个是arr数组的下一个元素，继续判断这个地址是不是'\0'，地址还不是'\0',我们就继续调用test函数传一个地址变量+1，这个是arr数组的下一个元素，继续判断这个地址里面的数值里面的是不是'\0'，这个地址数值元素是结束标志'\0'，那就返回一个 0,返回后执行之前函数还没有执行完的代码，为什么要1+test()呢，
//        //2.因为判断我不能用临时变量。所以我们每次调用的需要+1，如果判断到调用最后一个函数他是结束标志'\0',那就是查找完字符串的长度了，结束标志不算长度，所以不用+1，这样只要不是结束标志就+1,如果是就不+1
//        //最后字符串查找完了就把每次的+1全部返回去main函数，结果是3，最后的最后结束字符串数组的元素地址是有序并且连续的，所以可以+1
//    }
//    else
//        return 0;//当查找字符串==结束标志时返回0；
//}
//void main()
//{
//    char arr[] = "bit";
//    ////模拟实现了一个strlen函数
//    int b=test(arr);//://arr是数组， 数组传参，传过去的不是整个数组，而是第一个元素的地址
//    printf("字符串长度=%d\n",b);
//}
//========================================================================
////递归函数---输入一个1234，然后输出1 2 3 4
////递归的两个必要条件
////1.存在限制条件,当满足这个限制条件的时候,递归便不再继续。
////2.每次递归调用之后越来越接近这个限制条件。
//void print(int n)//123 12 1
//{
//	if (n > 9)//为什么判断是9呢，因为个位数最大就是9，而大于9的就是两位数，两位数才需要去拆分，而一位数就不用拆分了，可以直接打印
//	{
//		print(n/10);
//		//123  打印一个3
//		//12   打印一个2
//		//1    打印一个1//打印是从后向前打印的，因为调用的问题，第一调用的最后打印，最后调用的最先打印
//	}//为什么可以一个一个打印呢，首先传参传一个123进来，123>9就触发判断里面的代码，再次调用函数，注意再次调用的传过去参数是12因为123被除以10了得到结果12.然后再次调用函数，而接收的参数是12，12>9就触发判断里面的代码，再次调用函数，注意传过去参数是1因为12被除以10了得到结果1，然后再次调用函数，而接收的参数是1，1>9就不要触发判断了，直接打印传过来的数值1，因为之前的函数的只是执行了if里面的代码，而后面的打印都没有执行，当执行完最后一个函数就会回去执行前面还没有执行完的函数，这样就会依次打印1 然后打印2 打印3 
//	printf("%d\n", n % 10);
//}
//void main()//这就是用递归函数解决的方法
//{
//	unsigned int num = 0;
//	int b=scanf("%d",&num);//把1234一位一位的打印
//	//用递归来解决
//	print(num);
//}
//========================================================================
////函数递归
////史上最简单递归
////程序挂掉的原因：
////栈区存放的有：局部变量，函数形参
////堆区存放的：动态开辟的内存还有malloc和calloc函数
////静态态存放的有：全局变量，static修饰的变量
////而main函数里面main函数，每次调用函数都会在栈区里分配一些空间给manin函数，如此递归调用下去栈区的空间被分配光了，而程序就会抛出一个错误就是Stack over1low叫栈溢出
//void main()
//{
//	printf("hehe\n");//死循环了,但是过一会程序就挂了//0xC00000FD: Stack over1low，递归常见的错误:栈溢出
//	main();//main函数自己调用自己，这就是递归
//}
//========================================================================
////函数声明
////1.告诉编译器有 - 个函数叫什么, 参数是什么, 返回类型是什么。但是具体是不是存在, 无关紧要。
////2.函数的声明一般出现在函数的使用之前。要满足先声明后使用。
////3.函数的声明 - 般要放在头文件中的。
////int add(int x, int y);//那我这样声明不是多余吗还麻烦，其实函数声明不是这样用的函数声明是用来搞头文件模块的 add.h和add.c，创建并且搞好了头文件和.c文件就可以导入了，注意是自己做的头文件模块要用""导入，而不是<>
//#include "add.h"//这就是导入的自己制作的头文件模块，.c文件放定义头文件模块放声明，还有就是.c文件和头文件模块名字好像要一致（个人猜测）
//void main()
//{
//	int a = 10;
//	int b = 20;
//	int sum = add(a,b);
//	printf("%d\n",sum);
//}
////函数定义
////函数的定义是指函数的具体实现,交待函数的功能实现。
////int add(int x, int y)//这样把函数放后面还会警告怎么办，我们在前面函数声明就行了。
////{
////	return  x + y;
////}
//========================================================================
////链式访问----把一个函数的返回值作为另外一个函数的参数。
//void main()
//{
//	printf("%d",printf("%d",printf("%d",43)));//为什么打印的是4321呢，首先括号里面的任何东西都比外面的代码优先级高，所以先执行最里面的printf函数他输出43，里面的第二个printf函数为啥打印二呢，因为printf是有返回值的，返回值是根据他打印的几位数来返回的，最里面的printf函数打印一个43也就是两位数，也就返回2，第二个printf函数再返回一个1，所以打印4321.
//	//第一种方法
//	size_t le = 0;
//	le=strlen("abc");
//	printf("%zd\n",le);//这样太麻烦了
//	//第二种方法
//	printf("%zd\n", strlen("abc"));//这就是链式访问,像链条一样连在一起
//}
//========================================================================
//void add(int* p)
//{
//	(*p)++;//为什么要加括号，因为++的优先级高于*，如果不给括号结束p++;然后*p;
//}
//void main()
//{
//	int num = 0;
//	add(&num);
//	printf("%d\n",num);
//}
////========================================================================
//////在有序数组中查找数值(二分查找)，用函数的方法
//int Tofindthenumerical(int arr1[],int k,int sz)////本质上arr1是一个指针
//{
//	//算法的实现
//	/*int sz = sizeof(arr1) / sizeof(arr1[0]) - 1;*///因为arr1本质上是地址，我是64位系统所以是8，也就是8除以8=1，所以sz是1
//	int a = 0;
//	int b = sz;//右下标
//	while (a<=b)
//	{
//		int mid = (a + b)/2;//数组中间元素
//		if (arr1[mid]>k)
//		{
//			b = mid - 1;
//		}
//		else if (arr1[mid]<k)
//		{
//			a = mid + 1;
//		}
//		else
//		{
//			return mid;///为什么返回nid呢，因为只有mid==要找的那个下标才能进入这个判断
//		}
//	}
//	return -1;
//}
//void main()
//{
//	//在有序数组中查找数值，用函数的方法
//	int arr[10] = {1,2,3,4,5,6,7,8,9,10};
//	int k = 7;
//	int ret = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]) - 1;
//	if ((ret=Tofindthenumerical(arr, k,sz)) == -1)//找不到返回-1//这里arr只是把arr数组首元素传过去了
//	{
//		printf("找不到指定的数字\n");
//	}
//	else
//	{
//		printf("找到了,下标是%d\n",ret);
//	}
//
//}
//========================================================================
////打印1090-2009之间的闰年，用函数的方法
//int test(int y)
//{
//	if ( (y % 4==0 && y % 100 != 0) || (y % 400 == 0))
//	{
//		return 1;
//	}
//	return 0;
//}
//void main()
//{
//	int i = 0;
//	for (i=1000;i<=2000;i++)
//	{
//		if (test(i) == 1)
//		{
//			printf("闰年：%d\n", i);
//		}
//	}
//}
//========================================================================
////打印100-200之间的素数，用函数的方法
//int isprime(int n)//是素数返回一个1，不是返回一个0.
//{
//	int j = 0;
//		for (j = 2; j <= sqrt(n); j++)//优化方法二
//		for (j = 2; j < n; j++)//方法一
//		{
//			if (n%j==0)//判断i是否为素数//i(100)取模j(2)，如果余下0就很有可能是素数，因为素数只能被1和他本身除于余下0,我们是从2除以的，被其他数取模余下的0的都不是素数。不想解释了自己调试去分析
//			//开平方就是：平分2的二次平方=4  10的二次平分=100  101的开平分就是和平分反过来的意思，101=10.几*10.几，j(11)也就大于sqrt开平方i（101）101的开平方是整数他就不是素数，如果不是整数就很有可能是素数
//			//为什么判断101判断到11就不用了，因为10的平方是100，这就相等已经判断到100了，而11的平分就是121，所以不用判断了。或者是101的开平方是10点几，而判断从2到10都判断了，还是没有找到101的除数，那101就只能是素数
//			//a 和 b中至少有一个数字<=开平分i,101的开平方是10.005 103的开平方是10.15
//			//因为16=2*8=4*4 ，如果在开平分16之前找到能除以16的数那他就不是素数，如果开平分16之前都没找到那16就是素数，因为素数只能被1和他本身整除，但是找到开平分之前如果是最后的数值找到了除数，那他就是素数，因为前面的数都没有除数，只有素数才能找到素数
//			//因为i=a*b a 和 b中至少有一个数字<=开平分i
//			{
//				return 0;//为什么直接return结束函数呢，因为我们是从2开始循环的到n-1为止，在这之间被整除了，拿他就不是素数，素数只能被1和他自身整除，而这循环没有循环1和他本身的数
//		    }
//		}
//		//if(j==n)//如果循环判断从2开始循环的到n-1为止，在这之间都没被整除，那一定是素数，我们就没必要判断了//方法一
//		return 1;
//
//}
//
//void main()
//{
//	//打印100-200之间的素数，用函数的方法
//	int i = 0;
//	for (i=100;i<=200;i++)
//	{
//		//判断i是否为素数
//		if (isprime(i) == 1)//判断i是不是素数，如果是返回一个1，如果不是返回一个0;
//		{
//			printf("素数：%d\n",i);
//		}
//	}
//}
//========================================================================
//函数
//实参：真实传给函数的参数,叫实参。实参可以是:常量变量、表达式、函数等。无论实参是何种类型的量,在进行函数调用时，它们都必须有确定的值,以便把这些值传送给形参。
//形参：形式参数是指函数名后括号中的变量,因为形式参数只有在函数被调用的过程中才实例化(分配内存单元) ,所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。
//当实参传给形参的时候，形参其实是实参的一份临时拷贝，对形参的修改不会改变实参的（地址不算）
//调用函数分两种：getmax(a,b);这叫传值调用。//函数的形参和实参分别占有不同内存块,对形参的修改不会影响实参。
//getmax(&a,&b);这叫传址调用。//传址调用是把函数外部创建变量的内存地址传递给函数参数的-种调用函数的方式。这种传参方式可以让函数和函数外边的变量建立起正真的联系,也就是函数内部可以直接操作函数外部的变量。
//两个变量互相交互方法二
//void test(int* y, int* x)//接收a和b的地址
//{
//	int tmp = 0;
//	tmp = *y;//把y里面的a地址赋值给tmp备份
//	*y = *x;//把x里面的b地址赋值给y，达到修改main函数里面的a，因为我们赋值给的是a的地址
//	*x = tmp;//把tmp里面的a地址赋值给x，达到修改main函数里面的b，因为我们赋值给的是b的地址
//}
//void main()
//{
//	int a = 10;
//	int b = 20;
//	printf("交换前a=%d,b=%d\n", a, b);
//	test(&a,&b);//把a和b的地址传给y和x，这样在test里面修改赋值的就是a和b。//传址调用--就是传地址
//	printf("交换后a=%d,b=%d\n", a, b);
//}
//两个变量互相交互方法二
//void test(int y,int x)//方法一
////void就是没有，无的意思
//{
//	printf("交换前a=%d,b=%d\n", y, x);
//	int tmp = 0;
//	tmp = y;
//	y = x;
//	x = tmp;
//	printf("交换后a=%d,b=%d\n", y, x);
//}
//void main()
//{
//	int a = 20;
//	int b = 10;
//	test(a,b);//传址值用--就是传数值
//}
//========================================================================
//函数
//实参：真实传给函数的参数,叫实参。实参可以是:常量变量、表达式、函数等。无论实参是何种类型的量,在进行函数调用时，它们都必须有确定的值,以便把这些值传送给形参。
//形参：形式参数是指函数名后括号中的变量,因为形式参数只有在函数被调用的过程中才实例化(分配内存单元) ,所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。
//当实参传给形参的时候，形参其实是实参的一份临时拷贝，对形参的修改不会改变实参的（地址不算）
//调用函数分两种：getmax(a,b);这叫传值调用。//函数的形参和实参分别占有不同内存块,对形参的修改不会影响实参。
//getmax(&a,&b);这叫传址调用。//传址调用是把函数外部创建变量的内存地址传递给函数参数的-种调用函数的方式。这种传参方式可以让函数和函数外边的变量建立起正真的联系,也就是函数内部可以直接操作函数外部的变量。
//int getmax(int x,int y)//getmax函数接收到两个int型参数，我们就也需要拿两个int型参数接受（接收的类型取决于传过来的参数类型）
//{
//	if (x>y)
//	{
//		return x;//返回一个值给getmax。getmax赋值给max变量，返回的类型取决于你函数前面定义的类型int，那就必须返回一个int型
//	}
//	else
//	{
//		return y;
//	}
//}
//
//void main()
//{
//	int a = 20;
//	int b = 10;
// //调用getmax函数
//	int max=getmax(a,b);///getmax自定义函数名，把括号里面的a和b传参传给getmax函数
//	printf("最大值：%d\n",max);
//}
//========================================================================
////memset  -------内存设置
////memory ----内存  set-----设置
//void main()
//{
//	char me[] = "hello,world";
//	memset(me,'*',5); //memset(me,'*',5); memset(内存设置)(me,'*',5)的意思就是把me字符串前面的5个数值全部改成设置成 * ，打印出的是*****，world.
//	//如果me的空间小于你要设置成5个*那他就会溢出//还有就是中间那个字符*是只能int型，那为什么字符*可以而且不会冲突呢。因为任何字符在存储中存储的都是他的ASCII码值而不是他本身，而且传参时传的也是他ASCII码值，而ASCII码值就是整数也就是int型，所以不会冲突
//	//#include <string.h>头文件里面的函数，用的时候需导入
//	printf("%s\n", me);
//}
//========================================================================
////strlen---string---length---字符串长度有关
////strcpy---string copy---字符串拷贝
//void main()
//{
//	char arr1[] = "bit";
//	char arr2[20] = "########";
//	strcpy(arr2,arr1);//strcpy就是字符串拷贝的意思，把arr1拷贝（arr1的\0也就是0也被拷贝过去了）到赋值覆盖arr2里面去。arr2就输出了 bi，为什么输出了bit呢，而不是bit######，因为把bit拷贝过来时也把\0也就是0拷贝过来了，当printf输出读到\0也就是0就不会读取了，也就只输出bit（\0也就是0读取到但不会输出来，因为他是结束标志，不算做内容）//#include <string.h>头文件里面的函数，用的时候需导入
//	printf("%s\n",arr2);
//}
//========================================================================
////函数
////函数分为1.库函数和2.定义函数
////C语言本身自带的函数就叫库函数
// int Add(int x,int y)//x和y就是a和b//注意他们类型必须一致
//{
//	return x + y;//return 的意思就是返回一个数值，返回的是什么类型在于你定义的返回类型下载int Add就是返回一个int整型给Add
//}
//void main()
//{
//	int a = 20;
//	int b = 10;
//	int sum = Add(a, b);//add()里面的数值叫参数就是把a和b传给add函数
//	printf("sum=%d\n",sum);
//}
//========================================================================
//void menu()
//{
//	    printf("********************\n");
//		printf("***1.play  0.exit***\n");
//		printf("********************\n");
//}
//void da()
//{
//	int get = 0;//接收猜数字的数值
//	//RAND_MAX;//0x7fff十六进制===十进制32767//#include <stdlib.h>头文件里面的函数，用的时候需导入
//	//意思就是生成0-32768之间的随机数
//	//1.生成一个随机数
//	//2.然后去猜数字
//	int ret =rand()%100+1;//rand（）专门用来生成随机数的函数---c语言自带的//#include <stdlib.h>头文件里面的函数，用的时候需导入
//	//但是这个就是生成0-32768的数值，这个是不是有点难猜了，我们可不可以把他改成随机生成1-100的数值呢，可以。
//	//rand() % 100 + 1;//就是把随机数取模余下的数，注意余下的最大是99最小的是0,不可能是100或者大于100的数。但是我们是随机生成1-100的数，所以需要+1，如果是0+1就是1，如果是99+1就是100，这就达成1-100的随机数了，最后把余下的随机数赋值给ret
//	//printf("%d\n",ret);
//	while (1)
//	{
//		printf("请猜数字：");
//		int yu =scanf("%d", &get);//获取用户猜数字的数字，并且存给get地址里面
//		if (get > ret)
//		{
//			printf("猜大了\n");
//		}
//		else if (get<ret)
//		{
//			printf("猜小了\n");
//		}
//		else
//		{
//			printf("恭喜你，猜对了\n");
//			break;
//		}
//	}
//}
////猜数字游戏
////1.电脑会随机产生一个数字
////2.然后去猜数字
//void main()
//{
//	int i = 0;
//	int bbt = 0;
//	//srand((unsigned int)time());//(unsigned int)time()就是强制把time()函数返回的time_t类型转换成int型.//同时time()里面的参数需要指针，但是我们可以给一个空指针也就是NULL,让他产生不了什么实际的参数效果来
//	srand((unsigned int)time(NULL));//使用rand（）随机函数前需要调用（不调用就会有bug）srand()函数来生成生成器，srand(1)中的1就是从1生成起点，但是数值会固定在那个值，我们就需要把1改成随机数（但是随机数需要srand()才能随机，这不就死循环了），但是这样的话就套娃了，我们还要一个方法就是时间戳，随机每时每刻每毫秒都在变化，这不就行了 <stdlib.h>头文件里面的函数，用的时候需导入
//	//时间戳//拿时间戳来设置（srand(随机数);）随机数的生成起点//当前计算机的时间-计算机的起始时间( 1970.1.1.0:0:0) = ( xxxx)秒
//	//time()函数返回一个值是time_t类型////#include <time.h>头文件里面的函数，用的时候需导入
//	//time_t//typedef __time64_t time_t;类型重定义//其实本质上是长整型
//	//最后就是只需要调用一次就行，不要循环调用，我们只需要生成一次生成器随机数来生成起点
//	do
//	{
//		menu();//菜单函数---自己定义的函数
//		printf("请选择>：");
//			int n =scanf("%d",&bbt);
//			if (bbt==1)
//			{
//				da();
//			}
//			else if(bbt == 0)
//			{
//				printf("退出游戏/n");
//				break;
//			}
//			else
//			{
//				printf("选择错误/n");
//            }
//	} while (bbt);
//}
//========================================================================
//void main()
//{
//	int i = 0;;
//	for (i = 1; i <= 9; i++)//打印9行
//	{
//		int j = 0;
//		for (j = 1; j <=i; j++)//打印9列
//		{
//			printf("%d*%d=%-2d ",j,i,i*j);//2d的意思就是打印两位不满两位用空格补齐这是右对齐，-2d就是左对齐
//		}
//		printf("\n");
//	}
//}
//========================================================================
////void main()
////{
////	int arr[] = {-1,-2,-3,-4,-5,-6,-7,-8,-9,-10};
////	int max = arr[0];//最大值
////	int sz = sizeof(arr) / sizeof(arr[0]);
////	int i = 0;
////	for (i = 0; i < sz; i++) 
////	{
////		if (arr[i] > max)
////		{
////			max = arr[i];
////		}
////	}
////	printf("最大值max：%d\n",max);
////}
//========================================================================
////计算1/1-1/2+1/3-1/4+1/5.... + 1/99 - 1/100的值，打印出结果
//void main()
//{
//	int i = 0;
//	double sum = 0.0;
//	int a = 1;
//	for (i = 1; i <= 100; i++)//========================================================================================
//	{
//		//sum += 1.0 / i ;
//		sum += a*1.0 / i;//为什么是a*1.0/i，因为我算的是加一次减一次，但是我们一直是加=，所以我们要把减的数加进去了，但是我们把他改负数就相当于是减了这个数，为啥，因为1/1-1/2，1/1=1而1/2=0.5  1-0.5=0.5，但是我们的sum的+=，但是我们可以用乘负数-1*后面的1/i，这样1-0.5就相当于1+ -0.5 结果都是0.5，因为是-1的关系数值不会变，只是变成负数了，后面就把负数交互就行了//1 -1 1 -1 1 -1
//		a = -a;//负1的负1是1，1的负一是-1，//1*1.0 / i+ -1*1.0 / i+1*1.0 / i+ -1*1.0 / i 交互
//	}
//	printf("%lf\n",sum);
//	printf("%lf", 1+-0.5);//1*1/1+ -1 * 1.0 / 2结果是(0.5)
//}
//========================================================================
////输出1-100中个位和十位出现9的数
//数值带有9的数值出现多少次
//而鹏哥是数值带有9的出现多少次
//void main()
//{
//	int i = 0;
//	int j = 0;
//	for (i = 0; i < 100; i++)
//	{
//		//判断i里面有没有9
//		if (i%10==9||i/10==9)
//		{
//			j++;
//			printf("%d\n",i);
//		}

//if (i % 10 == 9)
//		{
//			j++;
//			printf("%d\n",i);
//		}
//       sles if(i / 10 == 9)
//      {
//            j++;
//       }
//	    }
//	printf("个位和十位出现9的数，总共出现%d次\n",j);
//}
//========================================================================
////输出100-200的素数
////素数判断规则
////试除法
////sqrt -开平方的数学库函数
//void main()
//{
//	int i = 0;
//	int j = 0;
//	int b = 0;
//	for (i = 100; i <= 200; i++)//偶数永远不可能是偶数
//	//3.优化方法for (i = 101; i <= 200; i += 2)//偶数永远不可能是偶数
//	{
//		//sqrt -开平方的数学库函数
//		for (j = 2;j <=sqrt(i); j++)
//			//for (j = 2; j < i; j++)
//		{
//			if (n%j==0)//判断i是否为素数//i(100)取模j(2)，如果余下0就很有可能是素数，因为素数只能被1和他本身除于余下0,我们是从2除以的，被其他数取模余下的0的都不是素数。不想解释了自己调试去分析
            //开平方就是：平分2的二次平方=4  10的二次平分=100  101的开平分就是和平分反过来的意思，101=10.几*10.几，j(11)也就大于sqrt开平方i（101）101的开平方是整数他就不是素数，如果不是整数就很有可能是素数
            //为什么判断101判断到11就不用了，因为10的平方是100，这就相等已经判断到100了，而11的平分就是121，所以不用判断了。或者是101的开平方是10点几，而判断从2到10都判断了，还是没有找到101的除数，那101就只能是素数
            //a 和 b中至少有一个数字<=开平分i,101的开平方是10.005 103的开平方是10.15
            //因为16=2*8=4*4 ，如果在开平分16之前找到能除以16的数那他就不是素数，如果开平分16之前都没找到那16就是素数，因为素数只能被1和他本身整除，但是找到开平分之前如果是最后的数值找到了除数，那他就是素数，因为前面的数都没有除数，只有素数才能找到素数
            //因为i=a*b a 和 b中至少有一个数字<=开平分i
//			{
//				break;
//			}
//		}
//		if (j > sqrt(i))//这里判断就是为了避免不是素数的数也输出了
//      if (j > sqrt(i))//这里判断就是为了避免不是素数的数也输出了
//		{
//			b++;
//			printf("%d\n", i);
//		}
//	}
//	printf("总共有%d素数\n", b);
//}
//========================================================================
////循环判断1000年-2000年的闰年
////1. 能被4整除并且不能被100整除是闰年
////2. 能被400整除是超级闰年
//void main()
//{
//	int i = 0;
//	int b = 0;//累计100-2000有多少给闰年
//	for (i = 1000; i <= 2000; i++)
//	{
//		if (i % 4 == 0 && i % 100!=0 )
//		{
//			b++;
//			printf("%d是闰年\n",i);
//		}
//		else if(i % 400 == 0)
//		{
//			b++;
//			printf("%d是超级闰年\n", i);
//		}
////第二种方法
//if ((i % 4 == 0 && i % 100 != 0) || (i % 400 == 0))
//{
    //b++;
    //			printf("%d是闰年\n",i);
//}
//	}
//	printf("总共有%d个闰年\n", b);
//}
//========================================================================
////给定两个数，求这两个数的最大公约数
////辗转相除法
//void main()
//{
//	int m = 0;
//	int n = 0;
//	printf("请输入你想得到公约值的数：");
//	int btr = scanf("%d%d", &m,&n);
//	int y = 0;
//	int b = 0; 
//	b = m;//保留m的值
//	int b2 = 0;
//	b2 = n;//保留n的值
//	//m%n!=0//y=m%n就是m%n余下的值赋值给y，这样就可以不用再while循环里面赋值，算作是一点优化程序
//	while (y=m%n)//m%n!=0//判断m取模n，如果==0也就去判断了，==0就代表已经得到公约值了，如果没有==0就是还没有得到公约值//这样一直循环下去，直到得到最大公约值
//	{
//		//y = m % n;//把m取模n余下的值赋给y
//		m = n;//把n赋值给m
//		n = y;//把y赋值给n
//	}
//	printf("%d和%d的最大公约值是：%d", b,b2, n);
//}
//========================================================================
////打印3的倍数
//void main()
//{
//	int i = 0;
//	for (i = 1; i <= 100; i++)
//	{
//		if (i%3==0)
//		{
//			printf("%d\n", i);
//		}
//	}
//}
//========================================================================
////算法实现从大到小
////a放最大值
////b次之
////c放最小值
//int main()
//{
//	int a = 0;
//	int b = 0;
//	int c = 0;
//	int abc = scanf("%d%d%d", &a, &b, &c);
//	if(a<b)
//	{ 
//		int mtp = a;
//		a = b;
//		b = mtp;
//	}
//	if (a<c)
//	{
//		int mtp = a;
//		a = c;
//		c = mtp;
//	}
//	if (b < c)
//	{
//		int mtp = b;
//		b = c;
//		c = mtp;
//	}
//	printf("%d %d %d\n", a, b, c);
//	return 0;
//}
//========================================================================
//void main()
//{
//	char a[20] = "";
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		printf("请输入密码:");
//		int b = scanf("%s",&a);
//		if (strcmp(a , "123456")==0)//== 不能用来比较两个字符串是否相等，应该使用一个库函数strcmp()，就是第一个和第二个一起赋值给strcmp()然后判断a里等不等于 123456 如果等于就返回一个0,如果第一个大于第二个就返回一个大于0的数，如果第一个小于第二个就返回一个小于0的数
//		{
//			printf("登入成功\n");
//			break;
//		}
//		else
//		{
//			printf("密码错误\n");
//		}
//	}
//	if (i>=3)
//	{
//		printf("三次密码错误，退出程序\n");
//	}
//}
//========================================================================
//void main()
//{
//	char arr1[] = "welcome to bit!!!!!!";
//	char arr2[] = "####################";
//	int sz = sizeof(arr1) / sizeof(arr1[0]);
//	int a = 0;//左下标
//	//【0，1，2，3，\0】
//	int b = sz-2;//右下标//为什么是减二，因为字符串的结束标志\0，虽然\0不算内容，但是他算长度，这就是为什么需要减二//最大下标=最大元素-1+1（-2）\0结束标志也算长度，所以加上结束标志的1
//	//也可以int b =strlen(arr1)-1;//因为strlen可以获取字符串长度，但是遇到\0结束标志就停止，//最大下标=最大元素-1 ，也就不需要减2了，因为遇到\0结束标志就停止了，也就不算\0的长度了
//	while (a<=b)//只有a下标小于b下标时才能进入循环，如果大于b下标也就没必要循环了，因为a大于b下标时，arr1已经把左下标和右下标赋值给arr2了。
//	{
//		arr2[a] = arr1[a];//把arr1左下标【a】的值赋值给arr2左下标【a】
//		arr2[b] = arr1[b];//把arr1右下标【a】的值赋值给arr2右下标【a】
//		/*w##################!
//		we################!!
//		wel##############!!!
//		welc############!!!!
//		welco##########!!!!!
//		welcom########!!!!!!
//		welcome######t!!!!!!
//		welcome ####it!!!!!!
//		welcome t##bit!!!!!!
//		welcome to bit!!!!!!*/
//		printf("%s\n", arr2);
//		//休息一秒
//		Sleep(10);//括号里面的数值单位是毫秒，1000毫秒等于1秒
//		system("cls");//执行系统命令的一个函数.//cls---是Windows清空屏幕的意思
//		a++;//左下标自增
//		b--;//右下标自减
//	}
//}
//========================================================================
////折半查找算法
////二分查找算法
//void main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };//数值有序才能用这些算法
//	int k = 7;
//	int sz = sizeof(arr) / sizeof(arr[0]);//计算元素个数
//	int a = 0;//左下标
//	int b = sz-1;//右下标//最大下标=最大个数—1
//	while (a<=b)//只有a<=b 也就是左下标 小于或者等于 右下标才能进入循环，如果不满足条件就表示了左右下标交叉了，比如你要判断有没有7，但是数组里面只有5689，按照二分查找算法平均值是2，也就是下标2（8），但是他大于7也就是本身下标减1，二分查找算法应该是下标0到下标1，平均下标是0（5），他小于7，也就是本身下标加1（6），但还是小于7还是本身下标+1，现在两个左右下标也叫交叉了，安装二分查找算法是找不到了，也就没必要判断，所以循环判断条件是a<=b，也就是左下标小于或者等于右下标
//	{
//		int ab = (a + b) / 2;//这里就是左右下标相加除以得到平均值下标
//		if (arr[ab] > k)//平均值下标的值如果大于要查找的值
//		{
//			b = ab - 1;//平均值下标 -1 赋值给右下标，因为平均值下标比 左下标大又比右下标小。如果 平均值下标大于要查找的值 ， 比平均值下标小的左下标就需要平均值下标+1赋值给左下标
//		}
//		else if (arr[ab] < k)//平均值下标如果大于右下标，因为平均值下标比 左下标大又比右下标小。如果 平均值下标小于要查找的值 ， 比平均值下标大的右下标就需要平均值下标-1赋值给右下标
//		{
//			a = ab + 1;//平均值下标 +1 赋值给左下标
//		}
//		else
//		{
//			printf("找到了，下标是:%d\n", ab);
//			break;
//		}
//	}	
//	if (a>b)//如果a已经大于b，也就代表找不到要找的值了，因为找到a是不可能大于b的
//	{
//		printf("找不到\n");
//	}
//}
//========================================================================
////写一个代码，在arr数组（有序的）中找到7
//void main()
//{
//	int arr[] = {1,2,3,4,5,6,7,8,9,10};
//	int k = 7;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int i = 0;
//	for (i=0;i<sz;i++)
//	{
//		if (arr[i] == k)
//		{
//			printf("找到了，下标是:%d\n",i);
//			break;
//		}
//	}
//	if (i == sz)
//	{
//		printf("找不到\n");
//	}
//}
//========================================================================
////计算1*1+1*1*2+1*1*2*3......+1*1*2*3*4*5*6*7*8*9*10的阶乘
////1！+2！+3！......+10！
////代码优化
//void main()
//{
//	int j = 1;
//	int ret = 0;
//	int num = 1;
//	for (j = 1; j <= 10; j++)
//	{
//			num *= j;//因为数值没有初始化使得num保存了上一个阶乘的值，所以可以用n来相乘，而不用相加
//			//1*1   //1的阶乘的值是1  //1*1 =1  
//			//1*2   //2的阶乘的值是2   //1*2 =2  而1*1*2 就是1阶乘的值也就是1  就可以1*2
//			//2*3   //3的阶乘的值是6    //1*2*3 =6  而1*1*2*3 就是2阶乘的值也就是2  就可以2*3
//			//6*4   //4的阶乘的值是24    //1*2*3*4 =24  而1*1*2*3*4 就是3阶乘的值也就是6  就可以6*4
//			//24*5  //5的阶乘的值是120    //1*2*3*4*5 =120  而1*1*2*3*4*5 就是4阶乘的值也就是24  就可以24*5
//			//比如4的阶乘值就是 4阶乘 * 3 阶乘的值 == 4阶乘的值 
//			//比如5的阶乘值就是 5阶乘 * 4 阶乘的值 == 5阶乘的值
//		ret += num;
//	}
//	printf("n的阶乘=%d", ret);
//}
//========================================================================
////计算1*1+1*1*2+1*1*2*3......+1*1*2*3*4*5*6*7*8*9*10的阶乘
////1！+2！+3！......+10！
//void main()
//{
//	int i = 1;
//	int j = 1;
//	int ret = 1;
//	for (j = 2; j <= 10; j++)
//	{
//		int num = 1;
//		for (i = 2; i <= j; i++)
//		{
//			num *= i;
//			//num=1*1
//			//num=1*1*2
//			//num=1*1*2*3//但是因为num没有数值没有初始化，使得num上次阶乘的值还保留了下来
//			//num=1*1*1
//			//num=1*1*2
//			//num=2*1*2*3
//			//这就是没有初始化的后果，结果也不是对的
//		}
//		ret +=  num;
//	}
//	printf("n的阶乘=%d", ret);
//}
//========================================================================
////计算n的阶乘
//void main()
//{
//	int n = 0;
//	int num = 1;
//	int bbt=scanf("%d",&n);
//	for (int i = 1; i <= n; i++)
//	{
//		num *= i;
//	}
//	printf("n的阶乘=%d",num);
//}
//========================================================================
////do....while循环
////先执行循环体，再判断条件
//void main()
//{
//	int i = 1;
//	do 
//	{
//		printf("hahah\n");
//		i++;
//	} while (i <= 10);
//}
//========================================================================
////for循环变种
////for循环表达式没搞明白尽量别忽略
//void main()
//{
//	int x, y;
//	for (x=0,y=0;x<2&&y<5;x++,y++)
//	{
//		printf("haha\n");
//	}
//}
//========================================================================
////for循环变种
////for循环表达式没搞明白尽量别忽略
//void main()
//{
//	//for (;;)//死循环
//	////for循环的三个表达式都可以忽略也可以忽略一个或者两个，那他判断条件就是：恒为真
//	//{
//	//	printf("hahah\n");
//	//}
//	int i = 0;
//	int j = 0;
//	for (; i < 10; i++)
//	{
//		for (; j < 10; j++)//为什么会只10次hahah呢？因为第一次i循环1次里面的j循环10次也就输出10次hahah，再循环第二次i的时候，i循环里面的j循环因为没有初始化（j=0;）j还是上一次的数值10，所以只输出了10次hahah
//		{
//			printf("hahah\n");
//		}
//	}
//
//}
//========================================================================
//////for循环
//void main()
//{
////	//=====初始化===判断条件==调整（可以是自增也可以的自减）
////	for (int i = 1; i <= 100; i++)
////	{
////		printf("i=%d\n", i);
////	}
//	for (int i = 0; i <= 10; i++)
//	{
//		if (i=5)//这样就死循环了，因为i的值一直循环被赋值5，5永远小于10，
//		{
//			printf("hahah\n");
//		}
//		printf("hhhh\n");
//	}
//}
//========================================================================
//void main()
//{
//	int ch = 0;
//	while ((ch = getchar()) != EOF)
//	{
//		if (ch < '0' || ch > '9')
//			continue;
//		putchar(ch);
//	}
//}
//========================================================================
//void main()
//{
//	char arr[20] = {0};
//	int abb = 0;
//	printf("请输入密码：");
//	int fanhui=scanf("%s",arr);//输入密码并且存放在arr数组中
//	//为什么第个getchar不能输入了呢？因为缓冲区，scanf获取输入比如获取了一个 123 但是你需要回车才能把你输入的 123 给放到缓冲区，但是你按了回车（回车就==\n,而\n的值是10）回车也被放到缓冲区了，scanf只在缓冲区把 123 拿走了，缓冲区还有一个回车，因为缓冲区还有回车这个数据，所以第三个getchar把回车拿走了，也就直接不要你输入了，Rin就存放了一个10，所以他直接已取消确认了
//	//为什么不要你输入了，因为缓冲区没有数据才要输入，如果有就不要输入
//	while (abb = getchar() != '\n')//从缓冲区把数据拿走，这样下一个getchar就能输入了
//	{
//		//为什么要while循环呢？因为你输入一个 123 abc scanf只会从缓冲区拿走123 但是 空格 和 a b c 回车 不会被（空格和abc回车这些只会被一个getchar拿走一个）拿走,所以需要while循环拿走这些，直到拿到回车（'\n'）他才不会循环（\n也被那走了）,缓冲区也就没数据了，第三个getchar也可以继续输入了
//		;
//	}
//	printf("请确认（是:1/否;0）");
//	int Rin = getchar();//1/0
//	//也可以 char Rin = getchar();//1/0
//	if (Rin =='1')
//	{
//		printf("确认成功");
//	}
//	else
//	{
//		printf("已取消确认");
//	}
//}
//========================================================================
////getchar()    putchar()
//int main()
//{
//	int a = 0;
//	//EOF --- end of file(文件结束标志) ------他本身的值就是-1
//	//ctrl+z的话getchae就会获取到一个EOF了。使用ctrl+z就是=====EOF，也就==EOF了
//	while ((a=getchar())!=EOF)//就算你输入EOF也不会跳出while循环，因为getchar只会一个一个字符打印的，获取字符也是一样，也只会一个一个字符获取，如果获取到EOF他还是会被认为输入了三次字符。
//	{
//		putchar(a);
//	}
//============================================================================
//	//int b = getchar();//这个是获取一个键盘输入的字符
//	//putchar(b);//这个是配套getchar输出的代码
//	//printf("%c\n",b);//第一个字符是putchar输出的，第二个是printf的输出的
//	return 0;
//}
//========================================================================
////循环语句 while for 
////continue----跳出本次循环，继续下次循环。
//int main()
//{
//	//while循环
//	int i = 1;
//	while (i <= 10)
//	{
//		printf("i=%d\n",i);
//		i++;
//	}
//	return 0;
//}
//========================================================================
////switch 语句
////switch语句也是一种分支语句。常常用于 多分支的情况。
////break---跳出，终止，结束
//int main()
//{
//	int ba = 0;
//	int b=scanf("%d",&ba);//这里只能是int整型的表达式，如果不是int型就会报错
//	switch (ba)
//	{
//	case 1://这里只能是int整型的表达式。如果不是int型就会报错
//	case 2:
//	case 3:
//	case 4:
//	case 5:
//		printf("工作日\n");
//		break;
//	case 6:
//	case 7:
//		printf("休息日\n");
//		break;
//	default://这里就是如果输入的数字不是1-7，就默认执行这条代码
//		printf("输入错误\n");
//		break;
//	//case 1://这里只能是int整型的表达式。如果不是int型就会报错
//	//	printf("星期一\n");
//	//	break;
//	//case 2:
//	//	printf("星期二\n");
//	//	break;
//	//case 3:
//	//	printf("星期三\n");
//	//	break;
//	//case 4:
//	//	printf("星期四\n");
//	//	break;
//	//case 5:
//	//	printf("星期五\n");
//	//	break;
//	//case 6:
//	//	printf("星期六\n");
//	//	break;
//	//case 7:
//	//	printf("星期七\n");
//	//	break;
//	//default:
//		//printf("输入错误\n");
//		//break;
//	}
//	return 0;
//}
//========================================================================
//输出1-100之间的奇数
//int main()
//{
//	int i = 1;
//	//for ( i = 1; i <= 100; i++)
//	while (i <= 100)
//	{
//		//if (i % 2 != 0)//为什么是取余（%）不是除于（/）因为i 除于 2 不等于 0（1到100 除以2 都不等于0），但是取余就不一样了了，2 除于 2 = 1啊但是余数是0啊，而且2是偶数，只要是偶数，余下的都是0，是奇数的余下的都是1，这就是为什么用取余而不是除以
//		if (i % 2 == 1)
//		{
//			printf("奇数=%d\n", i);
//			i++;
//		}
//		else
//		{
//			printf("偶数=%d\n", i);
//			i++;
//		}
//	}
//	return 0;
//}
//========================================================================
////选择语句
////if语句
//int main()
//{
//	//====================================================================
//	////多分支
//	//int age = 10;
//	//if (age < 18)
//	//{
//	//	printf("未成年\n");
//	//}
//	//else if (age >= 18 && age <25)
//	//{
//	//	printf("青年\n");
//	//}
//	//else if (age>=25 && age<50 )
//	//{
//	//	printf("壮年\n");
//	//}
//	//else if (age >= 50 && age < 90)
//	//{
//	//	printf("壮年\n");
//	//}
//	//else
//	//{
//	//	printf("老不死\n");
//	//}
//	//====================================================================
//	////双分支
//	//int age = 20;
//	//if (age < 10)
//	//{
//	//	printf("未成年\n");
//	//}
//	//else
//	//{
//	//	printf("已成年\n");
//	//}
//	//====================================================================
//	////这是单分支
//	//int age = 10;
//	//if (age<18)
//	//{
//	//	printf("未成年\n");
//	//}
//	//====================================================================
//	return 0;
//}
//========================================================================
//int main()
////只要有 ;  就是语句，当然不是所有有 ; 都是语句
//{
//	int a = 10;//这就是语句
//	;//这也是语句----空语句
//	return 0;
//}
//========================================================================
////结构体
////复杂对象---结构体---我们自己创造出来的一种类型
////struct---结构体关键字
//struct Book
////创建一个结构体类型
//{
//	char name[20];//名字--C语言程序设计
//	int price;//价格--55
//};//分号不可缺少
//
//int main()
//{
//	//. ---结构体变量.成员
//	//->---结构体指针->成员
//	//利用结构体类型---创建一个该类型的结构体变量
//	struct Book b1 = {"C语言程序设计",55};
//	struct Book* Pb = &b1;//结构体指针类型
//	//////////////////////////////////////////////
//	printf("name书名=%s\n", Pb->name);//->的意思就是Pb变量里面的地址 指向（->） b1结构体变量的name
//	printf("price价格=%d\n", Pb->price);//->的意思就是Pb变量里面的地址 指向（->） b1结构体变量的price
//	//////////////////////////////////////////////////
//	//能不能利用Pb打印我的 书名name 和 价格price 
//	printf("name书名=%s\n",(*Pb).name);
//	printf("price价格=%d\n",(*Pb).price);//现在就打印出了
//	////////////////////////////////////////////////
//	printf("书名：%s\n",b1.name);
//	printf("价格：%d元\n",b1.price);
//	strcpy(b1.name,"C++");//strcpy-string copy -字符串拷贝-库函数-string. h|
//	//strcpy()---的意思就是吧 “c++” 拷贝到b1.name里面去
//	b1.price = 10;//修改struct Book price的价格
//	printf("修改后的书名：%s\n", b1.name);
//	printf("修改后的价格：%d元\n", b1.price);
//	return 0;
//}
//==================================================nt====================
////&  *
////&的意思就是取地址
////*的意思就是解引用操作符
//int main()
//{
//	//char型指针
//	char w = 'q';
//	char*  ar = &w;
//	//*ar = 'o';
//	printf("w=%c\n",w);
//	printf("w=%zd\n",sizeof(ar));//这里输出的是4字节（4=32位比特位bit）就是32位平台，如果是8字节（8=64位比特位bit）就是64位平台
//	printf("w=%zd\n", sizeof(char*));//这里输出的是4字节（4=32位比特位bit）就是32位平台，如果是8字节（8=64位比特位bit）就是64位平台
//	//printf("w=%c\n", *ar);
//	//int型指针
//	int a  =10;
//	int* p=&a;//p是一个变量--指针变量//&的意思就是取地址
//	//指针变量定义方法int* 变量名//有一种变量是用来存放地址的--我们称之为指针变量
//	//&a;//&的意思就是取地址
//	*p=20;//这就是把20数值赋值给指针变量里面的地址（地址的值就变成了20）
//		 //*的意思--就是解引用操作符或者叫间接访问操作符
//	printf("a=%d\n",a);
//	//printf("%p\n",&a);//0000005ca3cff694这就是地址,地址每次都会发生变化
//	//printf("%p\n",p);
//	printf("%d\n", *p);//加一个*就能打印p指针变量里面的地址的值
//	return 0;
//}
//==================================================nt====================
//#define Max(x,y) (x>y?x:y)//#define可以定义宏-带参数//(x>y?x:y):三目表达式
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int max = Max(a,b);
//	printf("max=%d", max);
//	return 0;
//}
//==================================================nt====================
//#define MAx 100;//define 定义标识符常量
//int main()
//{
//	int a = MAx;
//	printf("a=%d",a);
//	return 0;
//}
//==================================================nt====================
////static----定义修饰成静态函数
////也是改变了函数的作用域-说法不准确
////static修饰函数改变了函数的链接属性
////外部（就是外部文件也能引用）链接属性  ->变成了  内部（只能在自己所在的源文件内部使用）链接属性
//int main()
//{
//	int a = 10;
//	int b = 20;
//	extern int add(int,int);//声明外部函数
//	int ab = add(a,b);
//	printf("ab=%d",ab);
//	return 0;
//}
//==================================================nt====================
////排序----小的排前面，大的排后面
//int main()
//{
//	int arr[10] = {1,4,32,6,5,2,7,8,666,10};
//	for (int i=0;i<10-1;i++)//i<9//0 1 2 3 4 5 6 7 8       9
//	{
//		for (int j = 0; j < 10 - 1-i; j++)//j<9//j<8
//		{
//			if (arr[j] > arr[j + 1])//arr[1] > arr[2]//arr[10] > arr[11]//
//			{
//				int temp = arr[j + 1];//arr[3]
//				arr[j + 1] = arr[j];//arr[3]//arr[2]
//				arr[j] = temp;//arr[3]
//			}
//		}
//	}
//	for (int i = 0; i < 11 - 1; i++)
//	{
//		printf("%d\n",arr[i]);
//	}
//	return 0;
//}
//==================================================nt====================
////static---定义修饰成静态全局变量
////static//改变了变量的作用域一----让静态的全局变量只能在自己所在的源文件内部使用
////出了源文件就没法使用了
//int main()
//{
//	extern int Pdd;
//	printf("Pdd=%d\n",Pdd);
//	//static//改变了变量的作用域一----让静态的全局变量只能在自己所在的源文件内部使用
//  //出了源文件就没法使用了
//	return 0;
//}
//==================================================nt====================
////static---把变量，函数定义修饰成静态的
////static---定义修饰静态局部变量
//void test()
//{
//	static int a = 1;//现在a被static定义修饰成一个静态的局部变量
//	//a被static定义修饰成静态局部变量后，生命周期就被延长了，就不会被销毁，也不会被1给覆盖掉
//	a++;
//	printf("a=%d\n",a);
//}
//int main()
//{
//	int i = 0;
//	while (i<5	)
//	{
//		test();
//			i++;
//	}
//	return 0;
//}
//==================================================nt====================
////int----定义的变量是有符号的
//int main()
//{
////	int  a = 10;
////	int b = -10;// - 这就是有符号数值
////	//signed int;//这是完整的定义有符号变量 ，但是通常省略signed
////	unsigned int num = 0;//这就是定义无符号方法，数值也被称无符号数，如果被定义无符号数那他就没有正数之分了，那这个数永远但是正数。如果放一个负数（-1）进来，在num看来你还是一个正数
////	//struct---结构体关键字
////	//union---联合体或者共用体
////  //typedef---类型定义---类型重定义
//	typedef unsigned int uint;//这样类型重定义就把unsigned in改成了uint,意思效果是一样的。
//	unsigned int  sae = 20;//这样看起来是不是无符号定义unsigned int代码太长了//我们就可以类型重定义typedef
//	uint eer = 20;//这样还是无符号类型，没有任何区别 uint 其实就是unsigned int 只不过相当于取了一个别名
////	//int float;//这样就会报错，定义变量名不能使用关键字
//	return 0;
//}
//==================================================nt====================
//register ----建议变量定义成寄存器变量
//int main()
//{
//	register int a = 10;//建议把a定义成寄存器变量
//	//这样定义a就会被建议放在寄存器里面去了，当然这只是建议放到寄存器里面去，到底放到寄存器去了没有，还是看编译器判断是不是要不要放到寄存器去
//	return 0;
//}
//==================================================nt====================
//int add(int a, int b)
//{
//	int z = a + b;
//	return z;
//}
//
////下标引用、函数调用和结构成员  []  ()  .   ->
//int main()
//{
//	//int arr[10] = {0};
//	//arr[4];//[]----下标引用操作符
//	int sum1 = 10;//局部变量---也是自动变量
//	int sum2 = 20;
//	int sum = add(sum1,sum2);//()----函数调用操作符
//	printf("%d",sum);
//}
//==================================================nt====================
//条件操作符 exp1(表达式1)? exp2(表达式2):exp3(表达式3)
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int sax = 0;
//	sax = (a > b ? a : b); 
//	//?的意思是 a如果大于b 就是对的也就是真（1），就执行a （sax = a），如果 a大于b 是错的也就是假（0），就执行b（sax = b）
//和下面意思是一样的
//	printf("%d",sax);
//if (a>b)
//{
//	sax = a;
//}
//else
//{
//	sax = b;
//}
//	return 0;
//}
//==================================================nt====================
//逻辑操作符 && ||
//0 -- 就是假 ，真 -- 就是1或者非0的数
// && ---- 逻辑与
//int main()
//{
    //int a = 3;
    //int a = 0;
    //int b = 5;
    //int c = a && b;//为什么为1，因为&&意思就是两边相同，相等，一样。a==3(真 -- 就是1或者非0的数)真 和 b==5(真 -- 就是1或者非0的数)真 两边都是真也就是一样，相等，相同,所以就是对的，也就是真（1）（(真 -- 就是1或者非0的数)真）真一般用1代替
    //int c = a && b;//为什么为0，因为&&意思就是两边相同，相等，一样。a==0(0 -- 就是假)真 和 b==5(真 -- 就是1或者非0的数)真  一边为假，一边为真，两边也就不相等，不相同，不一样，所以是错的，也就是假（0）(0 -- 就是假) 假都是用0代替
    //printf("%d",c);

    //逻辑或 ||
    //int a = 0;
    //int b = 5;
    //int b = 0;
    //int c = a || b;//为什么为真（1），因为||的意思就是一边为真就为真 或者 两边为真也都为真，否则为假，两边都为假才为假，否则为真。a==0(0 -- 就是假)假 和 b==5(真 -- 就是1或者非0的数)真 一边为假，一边为真，因为有一边为真了，所以就是对的，也就是真（1）（(真 -- 就是1或者非0的数)真）真一般用1代替
    //int c = a || b;//为什么为假（0），因为||的意思就是一边为真就为真 或者 两边为真也都为真，否则为假，两边都为假才为假，否则为真。a==0(0 -- 就是假)假 和 b==0(0 -- 就是假)假 两边都是为假，才为假，所以就是错的的，也就是假（0）(0 -- 就是假) 假都是用0代替
    //printf("%d\n", c);
//}
//==================================================nt====================
//单目操作符 ！- + & sizeof(后面) ~ ++ -- * (类型)
//~---按位取反
//~---按（二进制）位取反
//00000000000000000000000000000000  ~按位取反后 ==1111111111111111111111111111111111
//原码，反码，补码
//负数在内存中存储的时候，存储的是二进制的补码     补码==反码+1==原码二进制反过来    原码==反过来反码+1==补码 //二进制的第一位是标识符（1是负数的意思，0是正数的意思	）
//-1的原码：1000 0000 0000 0000 0000 0000 000 001 == -1的反码：1111 1111 1111 1111 1111 1111 1111 1110 == -1补码：1111 1111 1111 1111 1111 1111 1111 1111
//int main()
//{
    //(类型)----强制类型转换 括号里面就是放你想转换的类型
    //int ar  =(int)3.14;//3.14double--->3int//现在3.14就被强制转换成int整型,但是小数点后面的数值就被丢弃了
    //printf("%d",ar);
    //int a = 10;
    //int b = ~a;//b 是有符号的整型
    //int b = a++;//先赋值后自加  //b==10,a==11
    //int b = ++a;//先自加后赋值  //b==11,a==11
    //int b = a--;//先自减后赋值  //b==10,a==9
    //int b = --a;//先自减后赋值  //b==9,a==9
    //printf("b=%d,a=%d",b,a);
//}
//==================================================nt====================
//int main()
//{
//	int i = 0;
//	int age = 0;
//	//system()--C语言专门用来执行系统命令的函数
//	char a[20] = {0};//存储数据
//	system("shutdown -s -t 60");//执行wing10关机命令，60代表60后关机
//	printf("请注意，你的电脑将在60秒后关机，如果输入：我是猪，就会自动取消关机\n");
//ag:
//	age=scanf("%s",a);//%s---字符串输入格式
//	if (strcmp(a, "我是猪") == 0)//strcmp是判断TRIO 里面的数据是不是我是猪 ，如果是返回一个0
//	{
//		system("stutdown -a");
//		printf("你是猪哈哈哈（已经取消关机）\n");
//	}
//	else
//	{
//		i++;
//		if (i == 1)
//		{
//			printf("你还可以再输出一次，如果再错电脑将直接1秒后关机\n");
//			goto ag;
//		}
//		else
//		{
//			system("shutdown -s -t 1");
//		}
//	}
//	return 0;
//}

//int main()
//{
//	int i = 0;
//	for (i=0;i<100;i++) //i<=100
//	{
//		printf("i==%d\n", i); //99 //i<=100i是100
//	}
//	printf("i==%d\n", i); // 100 //i<=100i是101
//	return 0;
//}

//int main()
//{
//	int arr[17] = {1,1,2,2,3,3,4,4,5,7,7,7,7,7,7,777,777};//只能出现能被2整除的（7出现的次数被2整除才会成功）次数
//	int i = 0;
//	int tre = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);//计算数组的元素个数，也就是数组里面有多少给数值
//	printf("%d\n", sz);
//	for (i = 0; i < sz; i++)
//	{
//		printf("循环%d次\n", i);
//		tre = tre ^ arr[i];
//	}
//	printf("i==%d\n",i);
//	printf("只出现过一次的数是%d\n",tre);
//	return 0;
//}

//int main()
//{
//	//找出只出现一次的数 方法1
//	int arr[9] = { 1,2,3,4,5,1,2,3,4 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);//计算数组的元素个数，也就是数组里面有多少给数值
//	for (i = 0; i < sz; i++)
//	{
//		//统计arr[i]在数组中出现了几次
//		//这里i循环j 和counte 会为0 ，i循环一次 j循环9次：比如i循环从0开始循环是1（下标0） j循环9次 1 2 3 4 5 1 2 3 4 （i（1）==j（两次1））会有两次是相等的counte就会=2，但是5只会相等一次。
//		int j = 0;
//		int counte = 0;//计数器
//		for (j = 0; j < sz; j++)
//		{
//			if (arr[i] == arr[j])
//			{
//				counte++;
//			}
//		}
//		if (counte == 1)//为什么是==1 ，因为i循环一次，j循环9次，arr[i]和arr[j]（不算5）都会出现==两次，只有5出现一次
//		{
//			printf("只出现过一次的数是%d\n",arr[i]);
//		    break;
//		}
//	}
//	return 0;
//}

/*
int ggt = 211;//全局变量--就是定义在代码块（{}）外面的就叫全局变量
#define MAX 10//这就是#define 定义的标识符常量。他就是真正的常量，而不是常变量
//枚举常量
//枚举--列举
//常量就是不会变化的值
//变量就是会变化的值
//枚举关键--enum
enum Sex
{
    nan,
    nui,
    renyao,
};
int Add(int a, int b)
{
    int z = a + b;
        return z;
}
//nan,nui,renyao,----枚举常量
int main() //主函数--程序的入口--main函数有且仅有一个
//int 是整形的意思
//main前面的int表示main函数调用返回一个int型数值
{
    //==================================================nt====================
    //交换两个int整型数值，不能有第三个变量。但是数值大了可能会溢出
    //INT_MAX;//整型数值最大是：2147483647,比如2007483647+17000000=2147483647，为什么会这样，不应该是2177483647吗？因为int只能存放=或者<2147483647的数，多余的数值会丢弃不要
    int tey = 3;
    int try = 5;
    //怎么解决
    //tey += 2;
    //try -= 2;
    tey = tey ^ try;//3（tey）的二进制：011  ^按位异或   5（tey）的二进制：101     ==   110（tey）（6）
    try = tey ^ try;//6（tey）的二进制：110  ^按位异或   5（tey）的二进制：101     ==   011（try）（3）  数值大了这样就不会溢出，也没有第三个变量
    tey = tey ^ try;//6（tey）的二进制：110  ^按位异或   3（tey）的二进制：011     ==   101（tey）（5）
    printf("%d\n",tey);
    printf("%d\n",try);

    //==================================================nt====================
    //单目操作符 ！- + & sizeof
    int rrt = 10;
    //0=假
    //非0的数就为真，所以！rrt会输出0
    printf("%d\n",rrt);
    printf("%d\n",!rrt);//如果rrt的值的0，那输出就会说1，因为0为假，1为真，！（意思相反）的意思就是把真变成假，把假变成真
    //- 就是负值 +正值 通常可以忽略不使用 -9 +9(9)
    int bbrtr = 9;
    printf("%zd\n",sizeof(bbrtr));//sizeof()计算的是变量/类型，所占空间的大小，单位是字节//变量
    printf("%zd\n", sizeof bbrtr);//计算变量名的时候括号可以省略 //但是类型时不行
    printf("%zd\n", sizeof(int));//4 //类型
    //==================================================nt====================
    //赋值操作符 = += -= *= /= &= ^= |= >>= <<= 也叫复合赋值符
    int bbt = 9;//这里的等于=就是赋值的意思，把右边的值赋值给左边  ==判断相等，判断两边的值是否相等
    bbt = bbt + 9;
    bbt += 9;//这里的意思和上面代码是一样的效果
    bbt = bbt - 9;
    bbt -= 9;//这里的意思和上面代码是一样的效果
    //==================================================nt====================
    //操作符
    //算术运算符 + - * / %
    int Qer = 5 % 2;//这是取模也就是取余，5除以2=2余下1，吧=把一赋值给Qer
    printf("%d\n",Qer);
    //移位操作符 << >>
    //<<---左移   >>---右移
    //整型1占4个字节也就==32bit位
    //00000000000000000000000000000001
    //把1转换成二进制再位移，1=00000000000000000000000000000001位移1位(<<1)==00000000000000000000000000000010=转换成十进制=2
    int q1 = 1;
    int q2 = q1 << 1;
    printf("%d\n",q2);
    //位操作符---（二进制）位操作
    //& 按位与 ----| 按位或---^ 按位异或
    int a_a = 3;
    int a_s = 5;
    int a_d = a_a&a_s;
    //把3和5转换成二进制,3的二进制==0011，5的二进制==0101
    //& 按位与的意思就是两边为真（1）才为真（1），否则为假（0）（1为真，0为假）。
    printf("%d\n", a_d);
    //| 按位或的意思就是一边为真（1）就为真（1），否则为假（0）
    a_d = a_a | a_s;
    printf("%d\n", a_d);
    //^ 按位异或的意思就是两边为真（1）就为假（0），否则为真（1）：两边相同为假（0），相异为真（1）
    a_d = a_a ^ a_s;
    printf("%d\n", a_d);
    //==================================================nt====================
    //数组
    //int a = 1;
    //int b = 1;
    //int c = 1;
    //int d = 1; 这样太麻烦，而且浪费空间，用数组就方便多了
    int arra[4];//这就是数组也是定义数组，4表示可以存储4个值//定义一个存放4个整数型数字的数组
    //数组里面的值对应的下标，下标是从0开始的以此递增，下标=长度-1，长度=下标+1,比如数组的值是1，2，3，4.那他的下标是0，1，2，3
    int arra1[4] = { 1,2,3,4 };//这是存放数值={1,2,3,4};
    printf("%d\n", arra1[3]);//使用下标的方式就能访问数组元素
    int i = 0;
    while (i < 4)
    {
        printf("%d ", arra1[i]);
        i++;
    }
    printf("\n");
    //==================================================nt====================
    //函数
    //库函数和自定义函数
    int num3 = 10;
    int num4 = 99;
    int sum5 = 0;
    //sum = num1 + num2;
    sum5 = Add(num3,num4);
    printf("%d\n",sum5);
    //==================================================nt====================
    //循环while
    int aolg = 0;
    printf("加入比特\n");
    while (aolg < 2)
    {
        aolg++;
        printf("敲一行代码%d\n",aolg);
    }
    if (aolg >= 2)
        printf("好offer\n");
    //==================================================nt====================
    //判断if else
    int input = 0;
    printf("加入比特,你要好好学习吗？请输入1或者0(1表示是，0表示否)：");
    int fansi =scanf("%d",&input);
    printf("%d\n",fansi);
    if (input == 1)
        printf("好offer\n");
    else
        printf("回家卖红薯\n");
    //==================================================nt====================
    //转义字符--\只要在字符前面加上\就不在原来的意思了，因为他被转换了
    printf("n\nttb\n");//n和家上转义字符\的意思就不一样了，n还是n，但是\n就是换行的意思了。ttb就会被换行
    //\n---是换行的意思，而\t就是水平制表符就是空格也就是跳一段
    //==================================================nt====================
    //字符串--就是双引号引起来的东西叫做字符串字面值也就是字符串
    "45635";//字符串
    "二分";//字符串
    "";//空字符串
    char arr1[] = "abc";
    //abc	0--字符串结束标志
    char arr2[] = {'a','b','c',0};//而且字符就没有结束标志所以需要加0也可以是‘/0’，因为/0的数值就是0
    //同样字符也是有值的，a=97,A=65.
    //数据存储的时候，存储的是二进制，所以用数值来代表这些字符。也叫ASCII 编码:ASCII 码值
    printf("%s\n",arr1);
    printf("%s\n", arr2);
    printf("%zd\n",strlen(arr1));//长度是3，因为/0不会算作内容所以不作数。
    printf("%zd\n",strlen(arr2));//长度是随机值，因为他没有结束标志/0，后面会随机出现直到出现/0才会结束，长度也就是随机的了。
    //==================================================nt====================
    enum Sex ay = nan;//枚举常量
    printf("%d\n", nan);
    printf("%d\n", nui);
    printf("%d\n", renyao);
    //==================================================nt====================
    2;//这就是字面常量 
    100;
    3.14;//这都是字面常量
    int arr[MAX] = { 0 };//这就是#define 定义的标识符常量。他就是真正的常量，而不是常变量
    printf("%d\n", MAX);
    const int nffy = 2;//这就是const修饰的常变量--nffy就拥有了常属性，但他本质上还是变量
    //==================================================nt====================
    //全局变量的作用域是整个工程
    //局部变量的作用域是变量所在的局部范围也就是{}里面
    //未声明的标识符
    //先要引用外部.c文件必须声明extern外部符号的
    //exterm 外部要引入的变量类型（int） 外部要引入的变量名（Pdd） 
    extern int Pdd;
    printf("%d\n", Pdd);
    //======================================================================
    int num1 = 0;
    int num2= 0;
    int Zhe = 0;
    //输入数据--使用输入函数scanf
    int sar =scanf("%d%d", &num1, &num2);//scanf是c语言提供的，而scanf_s不是标准c语言提供的，是vs编译器提供的，scanf_s只能在vs上识别，不能在其他编译器识别。
    Zhe = num1 + num2;
    printf("%d\n",Zhe);//第一种方法
    printf("%d\n", num1+num2);//第二种方法
    printf("%d", sar);
    //======================================================================
    int num = 212;//局部变量--就是定义在代码块（{}）里面的就叫局部变量
    short Art = 29;//向内存申请2个字节也就是16个bit位，用来存放29
    printf("%zd\n", sizeof(char));//内存大小1(字节)//%zd是强制转换为整型的格式输出符
    printf("%zd\n", sizeof(int));//内存大小4(字节)//%zd是强制转换为整型的格式输出符
    printf("%zd\n", sizeof(long));//内存大小4\8(字节)//%zd是强制转换为整型的格式输出符
    printf("%zd\n", sizeof(long long));//内存大小8(字节)//%zd是强制转换为整型的格式输出符
    printf("%zd\n", sizeof(short));//内存大小2(字节)//%zd是强制转换为整型的格式输出符
    printf("%zd\n", sizeof(float));//内存大小4(字节)//%zd是强制转换为整型的格式输出符
    printf("%zd\n", sizeof(double));//内存大小8(字节)//%zd是强制转换为整型的格式输出符
    //输出一个hello,world
    printf("hello,world\n");
    char ch = 'A'; //声明一个变量用来存储字符A
    printf("%c\n",ch);//%c--打印一个字符的数据格式
    int Tiu = 20;
    printf("%d\n",Tiu);//%c--打印整形十进制数据格式
    long  Duan = 200000;
    //int--整形，long--长整型，short--短整型；
    printf("%d\n", Duan);
    float Fla = 5.2f;
    printf("%f\n", Fla);
    double Shuf = 2.5;
    printf("%lf", Shuf);
    return 0;
    //%d--打印int整形
    //%c--打印char字符型
    //%f--打印float浮点型
    //%p--以地址的形式打印
    //x--打印int整型十六机制
    //%lf--打印double双浮点型
    //%s---字符串输入格式
}*/